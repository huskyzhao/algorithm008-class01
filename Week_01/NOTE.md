# 算法学习笔记-Week-1

## 数组

数组可能是我们日常工作中最常见一种数据结构，而且也是最为基础的数据结构，我认为要掌握这种数据结构
并不难，只需要记住数组的以下特点:

* **内存连续性**：数组的本质实际上是虚拟内存中开辟的连续存储空间，因此连续性是数组最核心的特点。
* **按下标(index)查找效率为O(1)**：数组下标从0~n，根据下标查找任意元素都是常数级的时间复杂度，因此按下标查找的效率高
* **插入/删除元素效率为O(n)**：由于要确保数组内存的连续性，在数组中新增/删除元素时，往往需要移动目标元素后面的所有元素，导致效率低下。

我觉得这里应该实际编写一下数组的插入/删除操作的代码，体会一下数组这种数据结构为什么不适合用于频繁
更新数据的应用场景。推荐详细阅读Java中ArrayList的源码，这是一个Java中标准的可变长度数组的实现。

另外在数组的特点之外，我觉得数组这种数据结构对于零散内存的利用率可能比较低效，假设某种场景下我需要
申请大小为1M的数组，但是却没有足够的连续内存，那么可能就会创建失败，但实际上系统中可能有超过1M的零散
内存可供使用。

## 链表

链表实际上是相对于数组的一种互补的数据结构，链表的特点和数组恰恰相反：

* **内存不连续**：链表是一种链式结构，各个元素之间通过指针互相连接，因此不要求内存的连续性，通过指针可以找到某个元素。
* **查找元素效率为O(n)**：对于普通的单链表结构，要查找某个节点的元素，那就需要从链表的head遍历到目标节点的前一个节点，
然后通过next指针找到目标元素，因此时间复杂度为O(n)
* **删除元素效率为O(1)**：相对数组删除元素的低效来说，链表在删除某个节点的元素时，只需要调整节点指针的指向即可，因此是常数级别的复杂度。

链表由于加入了指针，因此细分出了很多不同的结构

* 单向链表
![单向链表](resources/单向链表.png)
* 双向链表
![双向链表](resources/双向链表.png)
* 循环链表

其实这些不同类别的链表，我认为区别就在于指针的指向，多少，以及最终构成一个什么样的逻辑结构，真正
需要了解其实并不是这些结构的特点，而是每个结构适合用于解决哪些问题。

例如在本周练习的LeetCode-355-设计推特的题目中，就应用了单向链表来存储最近发送的推特，即每次把
最新发送的推特放在链表头部，这样如果要取出最近的10条推特，就从头部往后遍历10条即可，我认为这实际上
是简单的LRU cache的实现(当然可能过于简单了，但是思路应该是一致的)

## 跳表

本周的课程中讲到了跳表，跳表本质上是链表的一种扩展结构，通过给链表增加更多维度，来提升检索效率。

使用跳表的重要前提条件：**链表有序**

跳表是一种插入/删除/查找都是O(log n)的一种数据结构，对标于平衡二叉树，但相对于平衡二叉树来讲，
跳表优势在于原理简单，实现起来相对容易。

这里老师提到了一个算法思维：对于一维的数据结构，可以采用升维的方式来降低时间复杂度。
而这里的跳表实际上也是采用升维的方式，具体的跳表思路如下：

首先一个有序的链表如下：

![原始链表](resources/跳表-原始链表.png)

第一步：建立1级索引(升维)

![1级索引](resources/跳表-1级索引.png)

可以看到，在建立了1级索引之后，原来要查找某个元素所需的O(n)的复杂度被降低为O(n/2)，因为每隔
1个元素建立了一个索引，有点类似于二分查找的思想，那么依次类推，建立了2级索引之后，如下图：

![2级索引](resources/跳表-2级索引.png)

在1级索引的基础之上，又将查找的复杂度降低了1/2，因此类推下去，最终查找的复杂度为O(log n)。

但是跳表这种数据结构我认为也有它的缺陷，当数据量很大的时候，建立索引的层级越多，需要占用的额外存储
空间也就越多，这样就涉及到如何权衡空间与效率的问题。 另外如果底层的原始链表会经常变化，新增或删除
元素都会导致索引的改变，如果变化频率过高，最终索引的位置可能并不理想，例如两个索引之间相隔的元素太多
会导致查询效率下降。

## 刷题笔记